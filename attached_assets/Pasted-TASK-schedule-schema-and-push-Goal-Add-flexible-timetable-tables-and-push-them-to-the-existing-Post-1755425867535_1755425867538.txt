TASK schedule-schema-and-push
Goal: Add flexible timetable tables and push them to the existing Postgres DB. Keep the change small and safe.

Actions:

In server/src/db/schema.ts, append after the existing exports the following enums and tables (keep imports you already have from pg-core):

import { boolean, json, pgEnum, pgTable, primaryKey, serial, integer, text, timestamp, varchar } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";

// --- Enums for schedule & attendance ---
export const sessionStatusEnum = pgEnum("session_status", ["PLANNED", "HELD", "CANCELLED", "SUBSTITUTED"]);
export const attendanceStatusEnum = pgEnum("attendance_status", ["PRESENT", "ABSENT", "EXCUSED", "LATE"]);

// --- Schedule patterns (weekly templates) ---
export const schedulePatterns = pgTable("schedule_patterns", {
  id: serial("id").primaryKey(),
  classId: integer("class_id").notNull().references(() => classes.id, { onDelete: "cascade" }),
  teacherId: integer("teacher_id").references(() => teachers.id, { onDelete: "set null" }),
  weekday: integer("weekday").notNull(),                 // 0..6 (Sun..Sat) or your local convention
  startTimeMin: integer("start_time_min").notNull(),     // minutes from midnight
  durationMin: integer("duration_min").notNull(),        // minutes
  location: varchar("location", { length: 255 }),
  rrule: text("rrule"),                                  // optional iCal rule
  exceptions: json("exceptions"),                        // optional JSON of excluded dates
  active: boolean("active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// --- Planned sessions (materialized from patterns) ---
export const plannedSessions = pgTable("planned_sessions", {
  id: serial("id").primaryKey(),
  classId: integer("class_id").notNull().references(() => classes.id, { onDelete: "cascade" }),
  teacherId: integer("teacher_id").references(() => teachers.id, { onDelete: "set null" }),
  startsAt: timestamp("starts_at", { withTimezone: false }).notNull(),
  endsAt: timestamp("ends_at", { withTimezone: false }).notNull(),
  curriculumItemId: integer("curriculum_item_id").references(() => curriculumItems.id, { onDelete: "set null" }),
  status: sessionStatusEnum("status").default("PLANNED").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// --- Realized sessions (what actually happened) ---
export const realizedSessions = pgTable("realized_sessions", {
  id: serial("id").primaryKey(),
  plannedId: integer("planned_id").references(() => plannedSessions.id, { onDelete: "set null" }),
  classId: integer("class_id").notNull().references(() => classes.id, { onDelete: "cascade" }),
  teacherId: integer("teacher_id").references(() => teachers.id, { onDelete: "set null" }),
  startsAt: timestamp("starts_at", { withTimezone: false }).notNull(),
  endsAt: timestamp("ends_at", { withTimezone: false }).notNull(),
  status: sessionStatusEnum("status").default("HELD").notNull(),
  progressPct: integer("progress_pct"),                  // 0..100
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// --- Substitutions (teacher replacement) ---
export const substitutions = pgTable("substitutions", {
  id: serial("id").primaryKey(),
  sessionId: integer("session_id").notNull().references(() => realizedSessions.id, { onDelete: "cascade" }),
  substituteTeacherId: integer("substitute_teacher_id").notNull().references(() => teachers.id, { onDelete: "cascade" }),
  reason: text("reason"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// --- Attendance (unique per student per realized session) ---
export const attendance = pgTable("attendance", {
  id: serial("id").primaryKey(),
  sessionId: integer("session_id").notNull().references(() => realizedSessions.id, { onDelete: "cascade" }),
  studentId: integer("student_id").notNull().references(() => students.id, { onDelete: "cascade" }),
  status: attendanceStatusEnum("status").notNull(),
  reason: text("reason"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (t) => ({
  uniq: primaryKey({ columns: [t.sessionId, t.studentId] }), // enforce one row per student+session
}));

// --- Helpful indexes (can be added later if push doesnâ€™t support) ---
// For large data, consider adding explicit indexes on (class_id, starts_at).


(Assume classes, teachers, and curriculumItems already exist; if symbol names differ, adapt FKs accordingly.)

Run exactly this command to apply schema without dealing with old migrations:

npm -w server run db:push


Definition of Done: db:push completes successfully; the new tables schedule_patterns, planned_sessions, realized_sessions, substitutions, attendance appear in the DB.

Commit message: feat(db): add schedule patterns, sessions, substitutions, attendance (pushed)